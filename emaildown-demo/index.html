<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />

    <title>Emaildown!</title>
    <script src="/music-game/build/react.js"></script>
    <script src="/music-game/build/react-dom.js"></script>
    <script src="/music-game/build/babel.min.js"></script>

    <script src="/jquery.js"></script>
    <!-- <script src="./lib/marked.min.js"></script> -->
    <script defer type="text/babel" src="./src/emaildown.jsx"></script>
    <link rel="stylesheet" type="text/css" href="./../cerulean.css">
    <link rel="stylesheet" type="text/css" href="./src/emaildown.css">
  </head>
  <body>

    <div class="row">
      <div class="col-xs-8 col-xs-offset-2">
        <h1>Emaildown!</h1>
        <div id="emaildown">app is loading!</div>
      </div>
    </div>


<script type="application/text" id="email2">
Hey there

It was fun talking to you today!

Here are the notes I promised.

  <strong>Algorithms:</strong>
    You should brush up on your basic algorithmics--this is very likely to come up in interviews. In particular, knowing the basic Big O complexity of commonly used data structure methods is likely to be valuable. You can see a useful list of those <a href="http://bigocheatsheet.com">here</a>.
    Especially as a junior developer, you'll get a lot of mileage out of getting really good at these.
    You've got a strong math background, so you should have a comparative advantage at learning about this stuff--you should take advantage of that!

  Here are some specific topics to look into:
    <a href="https://www.interviewcake.com/article/java/big-o-notation-time-and-space-complexity">Big O notation for time complexity.</a>
      It's really important to be comfortable with this! "Big O notation is like math except it's an awesome, not-boring kind of math where you get to wave your hands through the details and just focus on what's basically happening."
    <a href="https://en.wikipedia.org/wiki/Linked_list">Linked lists vs arrays.</a>
    <a href="https://www.quora.com/How-are-Python-lists-implemented-internally/answer/Adrien-Lucas-Ecoffet">Implementation of Python lists.</a>
      (This explanation is also true for other languages.)
    <a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary search trees.</a>
      You should know how to search, insert, and delete in a BST.
    <a href="https://www.ics.uci.edu/~eppstein/161/960215.html">Breadth first search vs depth first search.</a>
      Breadth first search always gets you shortest paths, depth first search doesn't.
      (You definitely be comfortable implementing these. I bet that someone will ask you to implement BFS over the course of your job search.)
    <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search.</a>
    <a href="https://en.wikipedia.org/wiki/Binary_heap">Binary heaps.</a>
    <a href="https://en.wikipedia.org/wiki/Suffix_tree">Suffix trees.</a>
    This is advanced stuff that is reasonably unlikely to come up in interviews, but I think it's interesting anyway:
      I mentioned the isometry between red-black trees and 2-3-4 trees: you can read about that in <a href="http://web.stanford.edu/class/cs166/lectures/05/Small05.pdf">these slides</a>, or many other places on the internet.
      I mentioned the little-known fact that heap insertion takes constant time; you can read about it <a href="http://wcipeg.com/wiki/Binary_heap#Insertion_2">here</a> if you're interested.
      <a href="https://en.wikipedia.org/wiki/Treap">Treaps</a> are a clever randomized BST implementation.
      <a href="http://www.bowdoin.edu/~ltoma/teaching/cs231/fall09/Lectures/10-augmentedTrees/augtrees.pdf">Augmented binary search trees</a> are a really useful data structure that can help you solve a massive variety of problems.
      I mentioned a neat way of making dynamic arrays with less than O(n) wasted space. <a href="http://link.springer.com/chapter/10.1007/3-540-48447-7_4">Here it is.</a>

  In general, my favorite resource for learning about algorithms is Skiena's Algorithm Design Manual--you can see a (legal!) PDF of it <a href="https://github.com/addyrookie/Depot-App/blob/master/gmail/The Algorithm Design Manual 2ed  by Steven S. Skiena.pdf">here</a>. It's a super fun and practical book--it's got lots of "war stories" interspersed throughout, about how the author has used the techniques he talks about in practise.
    For you, I'd recommend reading the book from about chapter 1 through 5, of which 3 is the highest priority chapter.
    You probably know most of the contents already, but I think that reading chapters 3 through 6 is a great refresher and an interesting perspective on designing algorithms in general; I think you might find it an interesting read.
    You should also take a look at chapter 12--it's fantastic, it's just a long catalogue of data structures and discussion of when different ones are useful.

  <strong>Low level systems:</strong>
    <a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">The stack and the heap.
    <a href="http://stackoverflow.com/questions/1119134/how-do-malloc-and-free-work">Implementation of Malloc.</a>
    <a href="http://stackoverflow.com/questions/499188/how-is-the-system-call-in-linux-implemented">Implementation of system calls.</a>
    <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Basic_algorithm">Mark and sweep garbage collection.</a>
    <a href="http://stackoverflow.com/questions/16699247/what-is-cache-friendly-code/16699282#16699282">CPU caches</a>
    If you're interested, <a href="http://danluu.com/new-cpu-features/">this long article</a> can tell you about a lot of modern CPU features.
    <a href="http://stackoverflow.com/a/200473/1360429">Threads vs processes.</a>
    <a href="http://c2.com/cgi/wiki?GreenVsNativeThreads">Green threads</a> are cooperative multitasking implemented by the programming language runtime, instead of being preemptive multitasking from the OS.

  <strong>Databases:</strong>
    <a href="http://stackoverflow.com/questions/1108/how-does-database-indexing-work">Database indexes.</a>
      It is very important to know about these! They speed up reads for the column that they are on, but they make writes slower and increase memory requirements. They are usually implemented with <a href="https://en.wikipedia.org/wiki/B-tree">B-trees</a>.
        B-trees are a kind of binary search tree which have fewer larger nodes, so that you don't have to do as many disk seeks.
        You can have <a href="http://stackoverflow.com/questions/795031/how-do-composite-indexes-work">composite indexes</a>, which are indexes on multiple columns.
    <a href="http://stackoverflow.com/questions/12915209/how-to-understand-an-explain-analyze">SQL explain.
    <a href="http://postgresguide.com/performance/explain.html">Query planning in Postgres.</a>
    NoSQL—It’s worth knowing a little bit about it. Mongo is probably the most famous NoSQL database. <a href="http://stackoverflow.com/questions/10553860/nosql-use-case-scenarios-or-when-to-use-nosql">Read this.</a>
    <a href="http://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it">ORMs.</a> There's kind of a cultural association with ORMs which makes it important to know about them: lots of old-school programmers in PHP or C# or whatever don't use them, and startups are wary of hiring people like that.

  <strong>HTTP:</strong>
    <a href="https://www.facebook.com/photo.php?fbid=217751861900214&set=gm.10153908057783909&type=3&theater">My favorite TCP joke.</a>
    <a href="http://stackoverflow.com/a/5970545/1360429">TCP vs UDP.</a>
    <a href="https://www.quora.com/How-do-browser-cookies-work/answer/Keith-Pieper">How do cookies work?</a>
    <a href="http://www.tutorialspoint.com/http/http_header_fields.htm">Different HTTP headers.</a>
    <a href="http://stackoverflow.com/a/504993/1360429">GET vs POST.</a>
</script>

<script type="application/text" id="email">
Hey $NAME,

Unfortunately, we're not going to move forward with your application right now. Interviewing is a messy process, and we know that we'll inevitably make mistakes as we iron out our process. We also believe in giving the people we interview honest feedback.

  This was a tough decision.
  We were impressed by your knowledge of $TOPIC.
  Your insights on the memcache and used car problems demonstrated a very broad knowledge of systems.
  You showed good knowledge of web systems and scaling applications, which are both highly valuable skills.
  We got the impression that you're a generally strong developer.
  You write really nice $LANGUAGE code.
  You did a great Connect-4, with good logic and good process.
    You had good abstracted code with a simple and efficient win check.
  We were impressed by your raw ability to get things done with code and make consistent progress toward solutions. Your methods were well-factored and your variables clearly named.
  We can tell you're smart, curious, and driven.

  However, you lacked depth in your knowledge of computer science.
   You didn't display the skills we need to see in working with complicated systems like in the Memcached problem.
  However, we didn't see the coding ability that we need to see to work with people.
    We didn't make it as far through the connect 4 or stock runs problems as we wanted to.
     Specifically, you struggled with the win check in the connect four implementation and did not come up with a clean way to check all line directions.
    The maze problem in particular is where we got stuck, especially on the details of breadth first and depth first search. While this isn't specifically a problem, when picking problems that are more algorithmic focused we do expect to see a strong, deep understanding of these details.
    Your code had a lot of duplication and not enough abstraction.
  The main thing that held us back was just the stumbling blocks while getting code written. This is one of the trickiest things about programming interviews, since there's a lot of factors affecting your performance, some of which are under your control and some of which come down to it being a fundamentally weird scenario.
  While speed isn't the only area we look at, it does raise the bar on other areas such as design and problem solving. We didn't see enough strength in these areas to use them as the basis for moving forward unfortunately.
  But we needed to see some kind of show of strength that we didn't see - we didn't see any terrible mistakes, but we also didn't see a single standout performance. We've found that having those areas of strength gels better with the structure of our process than being generally solid at a range of things. It also may well be that the structure of our interview just didn't uncover your strengths - we're always trying to get better at that.
  You're clearly experienced and you talk well about technology, but ultimately we need to see more sophisticated coding ability. This might be an interview stress issue or a process issue.
  On the memcached question, you didn't get as far through the problem as we wanted.
  It also felt that you weren't completely familiar or comfortable with $LANGUAGE.
  As a senior engineer we needed to see exceptional performance in one area of the interview (e.g coding, process or knowledge). While we saw strong performance across each of these areas, we couldn't clearly identify one area we could use as the peg to hang our recommendation to companies on.

Here's our advice.
  Often, simply getting more practice with interview-style problems can help - while we do our best, it's always going to be tough to figure out someone's strengths with a few short hours, and practicing interview problems helps you reduce that element of chance. We recommend InterviewCake.com and the book Cracking the Coding Interview as good resources on that front.
  You should practice your coding more. You can practice this by doing coding problems such as the ones you can find on Cracking the Coding Interview or InterviewCake.com, or by implementing the famous algorithms--breadth first search, binary heaps and so on.
  We recommend that you work on deepening your knowledge of CS.
  We recommend you practice talking more about software design. Web systems particularly are important. Two of our favorite resources for this are <a href="https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/">this blog post</a> and <a href="https://gist.github.com/vasanthk/485d1c25737e8e72759f">this gist</a>. Reading and understanding blog posts about how real-world systems are designed can help a lot when answering systems design questions as well. A helpful resourse for this is the blog <a href="http://highscalability.com/">High Scalability</a>.
  It also probably makes sense for you to put some effort into practicing writing simpler and shorter code: a lot of the time you wrote code that was more complex than necessary.
    One way of improving at this is to ask a more experienced programmer friend to review your code for you and suggest ways you can make it shorter.
  We think that you'd benefit a lot from a little more experience on larger projects, and studying how the Internet works at a lower level. A good way to do this is to try writing a web server from scratch, using just a raw socket. Try to build a routing system into your server, and create some soft of dynamic website (using cookies). We'd be happy to give you feedback on this, after you've done it.

  This was a tough call and we know this isn't a perfect process; we'd love to hear your honest feedback on how we might have improved it. We're also happy to hear any other questions you have.

  We think you're really high potential, and we'd love to talk to you if you're still job searching in two months (we of course hope for your sake that you're happily employed by then), or next time you want a job.

And again, we know this isn't a perfect process and we'd love to hear your honest feedback on how we might have improved it. We're also happy to hear any other questions you have.

Best,
Triplebyte Team

</script>
  </body>
</html>
