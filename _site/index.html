<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Buck Shlegeris</title>
  <meta name="description" content="Website of Buck Shlegeris.
">


  <link rel="stylesheet" href="/bootstrap.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://shlegeris.com/">
  <link rel="alternate" type="application/rss+xml" title="Buck Shlegeris" href="http://shlegeris.com/feed.xml">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$l', '$'] ],
        displayMath: [ ['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      messageStyle: "none",
      "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
    });
  </script>
  <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  <script src="/jquery.js"></script>
  <script type="text/babel" src="/main.js"></script>
  
</head>


  <body>

    

    <div class="container">
  <div class="row">
    <div class="col-sm-7 col-sm-offset-1 markdownify">
      
      <p class="post-meta"><time datetime="1969-12-31T16:00:00-08:00" itemprop="datePublished"></time></p>

      <hr/>

      <h1>Buck Shlegeris</h1>

<div class="lead">
<p>I am a software engineer from Australia. I have lived in San Francisco for most of the last three years. I'm interested in data structures and effective altruism.</p>
<p>Here are some things that I've written recently:</p>
</div>


  <h2><a href="/2016/08/16/dumb.html"> Dumb ideas</a></h2>

  <p class="post-meta"><time datetime="2016-08-16T00:00:00-07:00" itemprop="datePublished">Aug 16, 2016</time></p>

  <div class="shrink-headings">
    <p>I often have ideas to do things that I know everyone else probably thinks are stupid. But I often like my dumb ideas. Using the inside view, my ideas seem very reasonable.</p>

<p>But given how stupid everyone else would probably think my weird proposal is, I’m willing to accept a Chesterton’s fence argument that I shouldn’t actually think I’m right. What I really want to do is discuss my weird proposal with someone.</p>

<p>This is kind of an embarrassing conversation to have though. In the past it has felt like an argument which I end up losing and looking dumb. “Hey there,” it feels like I am saying. “I know that this idea sounds weird but I don’t understand why it’s so weird and it sounds like a good idea to me. Now that I’ve convinced you that I’m an extremely clueless person, do you feel like arguing with me until I give up?”</p>

<p>I only noticed this pattern recently. In the past, I’ve dealt with this problem by not telling people about most of my stupid ideas, or only telling people who I don’t think are very smart (so that if they point out flaws in my ideas and I feel bad about it, I can beat them in an argument), or only telling smart people about them when I am more confident than usual that my idea is a good one (which is only a smallish fraction of my weird ideas; usually I am convinced that my idea is bad).</p>

<p>But now that I’ve identified this pattern, it’s less of a problem. I plan to explicitly call attention to the fact that my idea is probably bad. I will clarify that I am aware of the Chesterton’s fence argument against my current idea, and I probably won’t follow through with it until I’ve followed the usual Chesterton’s fence due diligence. I’ll explain that I’m mostly interested in discussing my idea because I want to improve my understanding of the world. Armed with loudly signaled humility, I will enthusiastically face the prospect of being corrected by my trusted friends and learning more about why normal things are normal!</p>

  </div>

  <hr />

  <h2><a href="/2016/08/14/formatting.html"> Using formatting in writing</a></h2>

  <p class="post-meta"><time datetime="2016-08-14T00:00:00-07:00" itemprop="datePublished">Aug 14, 2016</time></p>

  <div class="shrink-headings">
    <p>When I’m writing, I often find myself wanting to use formatting to express myself. For example, I like using bold font to emphasize my most important sentences.</p>

<p>This makes my writing look unsophisticated. If I asked my father, who is a good and traditionally-minded writer, about this, I suspect he’d say that you can communicate anything you need to without formatting, and needing formatting is sign of weak writing ability.</p>

<p>I think my father would be wrong. English is much richer as a spoken language than a written language. I’m constantly stymied as I write by my inability to express the pattern of stress in the sentences I’m writing. I end up having to write different sentences from the sentences I’d speak, because I’m effectively working with just the small subset of English which happens to lose relatively little information when you destroy one of its main components.</p>

<p>Formatting gives me back some of that expressive power, and I’m very grateful for that. I will continue using gratuitous bold font in my writing, and I’ll just deal with the hit to my perceived classiness.</p>

<hr />

<p><a href="https://www.facebook.com/bshlgrs/posts/10208342088324560">comments on Facebook</a></p>

  </div>

  <hr />

  <h2><a href="/2016/08/14/bootcamp-attendees.html"> My advice to people about to attend bootcamps</a></h2>

  <p class="post-meta"><time datetime="2016-08-14T00:00:00-07:00" itemprop="datePublished">Aug 14, 2016</time></p>

  <div class="shrink-headings">
    <p>An EA who’s going to be attending a bootcamp in a few months emailed me a few days ago asking for advice. Here is an edited version of our conversation.</p>

<p>TL;DR:</p>

<ul>
  <li>When you are not yet employed as a programmer, you should focus intensely on getting a job, because it is a lot better to be a programmer than unemployed.</li>
  <li>To get a job faster, you should try to become a better programmer.</li>
  <li>To become a better programmer, you should do whatever programming practice is most entertaining and compelling to you.</li>
</ul>

<p>Here’s his email to me:</p>

<div class="panel panel-default">
  <div class="panel-body">
    <p>I'm curious about what you find to be the main (important) skills lacked by bootcamp graduates, and whether you have any advice on which one can acquire outside of a work environment.  Also, I'm wondering, as I will no longer be aiming to work at somewhere like Google, Slack, etc., should I put less emphasis on studying algorithms than I had been planning to?</p>

    <p>I'll be attending [a top coding bootcamp in a few months], and want to spend wisely the huge amount of free time I have before then.</p>

    <p>Should I shift some of the time I intended to spend on algorithm textbooks on general business books, books about design, and general books on problem solving and development, do you think?  Or is there something else that would be a better use of the next couple of months?</p>

    <p>I'm also curious whether you think it would be a waste at this point to spend a bunch of time learning about blockchains (after seeing whether I have an aptitude for this sort of work).</p>
  </div>
</div>

<p>And here’s my response:</p>

<hr />

<p>Hey there.</p>

<p>Here are some rough thoughts.</p>

<blockquote>
  <p>I’m curious about what you find to be the main (important) skills lacked by bootcamp graduates, and whether you have any advice on which one can acquire outside of a work environment.</p>
</blockquote>

<p>Bootcamp grads don’t tend to totally lack important skills, they’re just very junior. The best thing to do is to try to learn more about everything about programming.</p>

<blockquote>
  <p>Also, I’m wondering, as I will no longer be aiming to work at somewhere like Google, Slack, etc., should I put less emphasis on studying algorithms than I had been planning to?</p>
</blockquote>

<p>Algorithms are covered in interviews at a lot of companies, including lots of companies where the day-to-day work is very practical full stack development. And for many people, implementing algorithms is a good way of getting better at programming. So my advice is to study algorithms even if you don’t plan to take a Google job. (<a href="/2016/08/14/algorithms.html">Here’s my advice on studying algorithms</a>.)</p>

<p>(FWIW, it’s probably worth applying to Google even if you don’t want to work there. Companies will move much faster with you if you tell them that you have a Google onsite scheduled, and they’ll be much happier to negotiate.)</p>

<blockquote>
  <p>Should I shift some of the time I intended to spend on algorithm textbooks on general business books, books about design, and general books on problem solving and development, do you think? Or is there something else that would be a better use of the next couple of months?</p>
</blockquote>

<p>Here’s what I think your plan should be. First, <strong>do whatever it takes to get a programming job</strong>. This mostly involves useful things like getting good at programming, but it probably also involves some less immediately useful things like learning about algorithms. <strong>Getting a programming job should be your top priority</strong>, because after you get a job, you’re getting paid and you can claim that you’ve worked as a professional software engineer, which makes every subsequent job enormously easier to get.</p>

<p>I think that at this point, getting better at programming is higher value than getting better at any of those other things. (I’m also somewhat skeptical that you can get much better at those other things by reading books.)</p>

<p>How do you get better at coding? I think you should code as much as possible, and I don’t think it really matters what you code. It’s easiest for me to be productive and hardworking when I’m working on something that excites me. If that’s true for you too, then the biggest priority for you is to <strong>find something you enjoy working on and then work on it a bunch.</strong></p>

<p>I’m going to propose a bunch of different things you can do, all of which are worth your time. I think you should probably do whichever one you enjoy the most.</p>

<p>The first step is to get comfortable enough coding that you don’t get stuck all the time. (Analogously, I think that it’s really important when learning musical instruments to get good enough that playing the instruments is fun. <a href="http://www.jefftk.com/p/teach-yourself-any-instrument">Jeff Kaufman agrees</a>.) If you want to improve your coding fluency, you can do beginner things like Codecademy, which is quite well built to give you practice at writing simple, syntactically correct code. You already got into App Academy, so you’re probably beyond the level taught there. But if you’re ever demoralized and want something easy, learning the basics of a new language on Codecademy is a decent use of time.</p>

<p>Then you want to work on some coding projects. <a href="https://gist.github.com/bshlgrs/2363068d9775ca18390cee5fec279f3e">Here are some ideas I wrote down on this topic once</a>. Do whichever of those seems fun. If you want, you can send me code and I’ll comment on it for you. If you get stuck on weird bugs, take the opportunity to post on StackOverflow if that isn’t too stressful for you. Posting questions on StackOverflow is a great learning experience.</p>

<p>Here is a list of some other things you might be interested in doing. All of them are useful and you should do whichever one looks like the most fun. If you get stuck on one of these, email me or ask on StackOverflow about it.</p>

<ul>
  <li>Take a simple-ish project (eg Connect–4) and implement it in multiple programming languages</li>
  <li>Learn to use Github Pages, and put a shitty personal website on it
    <ul>
      <li>Make little bits of Javascript and put them on your personal website.</li>
      <li>Learn some HTML and CSS. Learn to use Bootstrap</li>
    </ul>
  </li>
  <li>Take a MOOC on algorithms. (I like the Roughgarden course).</li>
  <li>Learn Sinatra, try to make a simple web application with it</li>
  <li>Learn some C.</li>
  <li>Learn Haskell (this one is especially good if you like math)</li>
  <li>Read a textbook on algorithms. My favorite is Skiena’s Algorithm Design Manual, because I really enjoy the writing style.</li>
</ul>

<p>After you have a coding job, start trying to learn whatever other stuff.</p>

<p>Re blockchain stuff: I think it’s worth your time to learn about it if and only if you find it interesting :) If learning about it gives you an excuse to practice more programming, so much the better.</p>

<p>Apologies for length; I wrote this partially because I wanted to take the opportunity to express all these ideas for myself, so that I can write them down for a larger audience at some point.</p>

<p>Buck</p>


  </div>

  <hr />

  <h2><a href="/2016/08/14/algorithms.html"> My advice on studying algorithms</a></h2>

  <p class="post-meta"><time datetime="2016-08-14T00:00:00-07:00" itemprop="datePublished">Aug 14, 2016</time></p>

  <div class="shrink-headings">
    <p>Software engineering interviews often ask whiteboard algorithms questions. Here’s my advice on how to study for them. (My credentials on this topic are:  I have passed a lot of whiteboard interviews, including at Google and Apple;  as part of my job I prepare programmers for these algorithm interviews; I have conducted more than 200 technical interviews on programmers with a very wide variety of backgrounds.)</p>

<p><strong>I’m speaking for myself, not for Triplebyte, in this post.</strong></p>

<p>Other topics than algorithms are also covered in interviews. Triplebyte <a href="blog.triplebyte.com/how-to-pass-a-programming-interview">has a blog post</a> which has useful information on studying for those. I primarily intend this post to be a supplement to section 2 of that post.</p>

<h2 id="background-why-do-companies-ask-algorithms-questions">Background: why do companies ask algorithms questions?</h2>

<p>In real life, programmers spend almost none of their time implementing binary search trees or graph search algorithms. So why do companies ask so many questions about them?</p>

<p>There’s both a <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/WatsonianVersusDoylist">Watsonian and a Doylist</a> interpretation of this question–“why are algorithms questions useful to companies to ask” has one answer, and “what is the actual causal mechanism by which companies decided to ask algorithms questions” has another.</p>

<p>I’ll start out by explaining the reasons to ask algorithms questions, and then move on to more cynical explanations for their prevalence.</p>

<p>To start with, a lot of professional programmers aren’t able to do very basic things. For example, I might have a list of Customer objects, each of whom has an array of Purchase objects, and I want to get the names of the five customers who have spent the most over the last week. My guess is that maybe 50% of professional programmers would not solve this problem within 30 minutes. You don’t want to hire such people by mistake.</p>

<p>Less pessimistically, when you’re interviewing someone for a programming job, you’re trying to find out how good they are at solving hard and confusing programming problems where they need to keep lots of details in their head at once. In real life, confusing complicated problems happen because you’re working on projects that are large enough to take weeks, and you need to think about a lot of different parts of software at once. But interviews don’t normally have enough time to let you get that deep into a programming problem. So instead of asking you a problem that is only difficult because of how large it is, they ask you questions which are short and difficult.</p>

<p>How can you come up with complicated but short coding problems which are also simple to describe? I think algorithmics is a good choice here. Algorithmics is the most complicated area of computer science that almost all software engineers know about, and it allows lots of easy-to-describe, tricky-to-implement problems.</p>

<p>Now here’s are some more cynical historical notes.</p>

<p>Interview processes are awkwardly sticky. Engineering teams are comprised entirely of people who passed the technical interview of that team. So everyone is personally incentivised to believe and say that their interview process is extremely accurate at measuring software engineering ability. So once a culture of algorithmic interviewing gets established at a company, it’s hard to change it.</p>

<p>Also, everyone knows that Google had an amazing team 10 years ago (and to a lesser extent still today), and Google asked algorithmic interview questions back then. Most companies are slightly insecure about not being Google (because they’re used to losing their best candidates to Google), so they are tempted to imitate Google’s interview process.</p>

<p>At worst, algorithms interviews can turn into some weird hazing process. Sometimes companies get totally convinced that some random brainteaser is the secret sauce to finding great candidates, and you can never change their mind about it.</p>

<p>Overall, I wouldn’t ask traditional hard algorithms questions in interviews. At worst, algorithms questions are extremely bad interview questions. I’ve written on occasion about <a href="/2016/04/22/dumbest-algorithm-problem.html">questions I particularly hate</a>. Algorithms questions are particularly bad when they’re more like brainteasers and require more leaps of insight. (If you want to build an algorithm interview process, feel free to email me and I can give you more detailed opinions on how to ask questions that don’t have these problems.)</p>

<h2 id="how-to-study">How to study</h2>

<p>I think there’s sort of two different skills involved in answering algorithms questions. Firstly, you need to know all of the classic algorithm and data structure material. Secondly, you need to be able to quickly produce algorithmic logic on a whiteboard under pressure. I’m going to discuss these topics separately.</p>

<h3 id="canonical-algorithms-material">Canonical algorithms material</h3>

<p>There’s a pretty consistent set of core algorithms knowledge to acquire that companies will test you on. Companies are incentivised not to ask questions relying on material which isn’t in this list, because many good programmers don’t know it and the companies will end up failing good people.</p>

<p>Here’s a list of the data structures material you should know:</p>

<ul>
  <li>List structures: arrays, dynamic arrays, linked lists</li>
  <li>Set and map structures: hash maps, binary search trees, heaps</li>
</ul>

<p>For each of the data structures, you should know how all of its essential methods are implemented and their runtimes. (Essential methods for lists are <code class="highlighter-rouge">set</code>, <code class="highlighter-rouge">get</code>, <code class="highlighter-rouge">pushAtEnd</code>, <code class="highlighter-rouge">popAtEnd</code>, <code class="highlighter-rouge">insertByIndex</code>, <code class="highlighter-rouge">removeByIndex</code>. Essential methods for sets are <code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">remove</code>, <code class="highlighter-rouge">contains?</code>). You should know how to write code that uses the implementation of the data structures; for example, you should be able to implement a <code class="highlighter-rouge">getNearestElementTo(x)</code> method which takes a binary search tree and searches for the closest value to <code class="highlighter-rouge">x</code> in the tree.</p>

<p>Other notes on this:</p>

<ul>
  <li>You should know that your binary search tree implementations need to have logic for balancing, but it’s okay if you don’t know the details. (Optional material: if you want to quickly learn an implementation of self balancing BSTs check out <a href="/2016/07/02/hash-ordered-treaps.html">treaps</a>. If you want to understand how red-black trees work, learn about <a href="https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf">left-leaning red-black trees</a> or 2-3-4 trees instead.)</li>
  <li>You should probably know that a queue <a href="http://stackoverflow.com/a/69436/1360429">can be implemented with two stacks</a></li>
</ul>

<p>You should be able to implement all of the following algorithms:</p>

<ul>
  <li>Graph algorithms: Breadth first search, depth first search, Dijkstra’s algorithm</li>
  <li>One fast sorting algorithm; I recommend mergesort or quicksort</li>
  <li>Binary search on an array. This one is super fiddly to get right and it’s worth writing the code even if you roughly understand the algorithm.</li>
</ul>

<p>You should be roughly comfortable with Big O notation.</p>

<p>How should you learn all this? My favorite resource is Skiena’s Algorithm Design Manual. All the above material is covered in chapters 2-6. I like it because the writing style is really engaging and it focuses on the parts of the material which I think are the most important. It’s available free on the internet <a href="https://github.com/addyrookie/Depot-App/raw/master/gmail/The%20Algorithm%20Design%20Manual%202ed%20%20by%20Steven%20S.%20Skiena.pdf">here</a>. One downside of this book is that it gives code examples in C, which makes it less accessible to programmers who can’t read C. If you read this book, I think it’s worth reading chapters 1-6 and chapter 12. This reading will cover quite a bit of material which is extremely unlikely to come up in interviews, but I think that the unnecessary material does a good job of reinforcing the really core stuff.</p>

<p>If you want a briefer explanation, I like the explanations in Craking the Coding Interview and on <a href="https://www.interviewcake.com/">InterviewCake.com</a>.</p>

<p>I think Skiena’s book is way better than the famous CLRS textbook, which is extremely dry and somewhat pedantic.</p>

<p>I have a few notes on graph algorithms <a href="/2016/07/02/graph.html">here</a> that might be a useful resource.</p>

<h3 id="canonical-algorithmic-skills">Canonical algorithmic skills</h3>

<p>So that’s the core knowledge required for interviews. Here are the different kinds of programming skills that are tested, together with my favorite resource for learning them.</p>

<p>Cracking the Coding Interview is an extremely useful resource for all of this. I wrote some notes on it <a href="/2016/06/22/ctci.html">here</a>.</p>

<p>Here are the most common central components of algorithms interview problems:</p>

<ul>
  <li>Dynamic programming: learn it by reading Skiena chapter 8, or by reading the Cracking the Coding Interview chapter on this topic.</li>
  <li>Recursion: Cracking the Coding Interview has a great chapter on this.</li>
  <li>Iterating around and over the famous data structures. CtCI has good questions about this for each of the individual data structures. Eg for BSTs, you could refer to the CtCI tree chapter.</li>
  <li>Composing fast data structures for a problem. <a href="https://github.com/bshlgrs/data-structure-composer/blob/master/amazing_outcome.md">Here are some examples</a> of this kind of problem.</li>
</ul>

<p>My main advice is to do a bunch of problems from Cracking the Coding Interview. I listed in my notes on it the problems that I thought were most important.</p>

<p>Here’s a general note on studying these problems: I think it’s probably fine to “cheat” by reading the answers. I think you’re better off giving up on the problems and reading the solutions than giving up totally on doing practice interview problems.</p>

<h3 id="non-technical-aspects-of-succeeding-at-algorithm-interviews">Non-technical aspects of succeeding at algorithm interviews</h3>

<p>It’s worth practicing answering these questions under pressure, with a real human asking them to you. For more advice on this, see the <a href="http://blog.triplebyte.com/how-to-pass-a-programming-interview">Triplebyte blog post</a>, particularly points 2, 3, and 7.</p>

<h2 id="learning-further-about-algorithms-and-data-structures">Learning further about algorithms and data structures</h2>

<p>Suppose you’re excited about algorithms and data structures for their own sake, as opposed to for the mercentile purpose of getting a job. How should you learn more?</p>

<p>The easiest things to learn more about are relatively simple data structures that for whatever reason aren’t part of the core data structure canon I described above. For example, <a href="/2016/07/02/hash-ordered-treaps.html">treaps</a>, <a href="https://en.wikipedia.org/wiki/Skip_list">skip lists</a>, <a href="http://www.bowdoin.edu/~ltoma/teaching/cs231/fall09/Lectures/10-augmentedTrees/augtrees.pdf">augmented BSTs</a>, and the <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint set data structure</a> are all pretty easy to understand and I think they’re all really cool.</p>

<p>There are some data structure topics which were harder to understand but well worth the effort. For example, <a href="http://web.stanford.edu/class/cs166/lectures/05/Small05.pdf">this set of slides</a> which explains BTrees and 2-3-4 trees.</p>

<p>For more interesting data structures material, my favorite resources are:</p>

<ul>
  <li>Chapter 12 of Skiena, and other later chapters of Skiena</li>
  <li><a href="http://web.stanford.edu/class/cs166/">CS166</a>, an awesome Stanford class. The slides are awesome and quite readable. I also enjoyed doing some of the problem sets. For further data structures fun, I recommend <a href="http://web.stanford.edu/class/cs166/handouts/090%20Final%20Project%20Topics.pdf">the project ideas handout</a> from the class.</li>
  <li>I’m quite proud of the work I did <a href="http://shlegeris.com/2016/06/16/kth-richest.html">here</a> on a particular data structure problem which isn’t actually that hard but was fun as an amateur activity. My solution to that problem involves several ideas from advanced data structures and I think it’s quite neat.</li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li>Triplebyte, <a href="https://blog.triplebyte.com/how-to-pass-a-programming-interview">How To Pass A Programming Interview</a>. I endorse most of this content.</li>
  <li>Steve Yegge: some old posts like <a href="https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions">this one</a>, <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html">Get That Job At Google</a>. I think a lot of his ideas are wrong, but they’re interesting to read.</li>
  <li><a href="https://www.interviewcake.com/">InterviewCake.com</a> is a more fun and engaging self-study tool than Cracking the Coding Interview.</li>
</ul>

  </div>

  <hr />

  <h2><a href="/2016/07/31/counterfactuals.html"> Counterfactual reasoning</a></h2>

  <p class="post-meta"><time datetime="2016-07-31T00:00:00-07:00" itemprop="datePublished">Jul 31, 2016</time></p>

  <div class="shrink-headings">
    <p>There’s a kind of thought process which I enjoy, which I think is pretty core to EA. It’s a particular approach to answering questions of the form “should I do X”. It involves counterfactual reasoning, a bunch of basic microeconomics, and careful attention to your values.</p>

<p>For example, I recently saw someone stealing a bike outside a BART in Oakland. Should I have called the police on the guy? Here are some of the considerations I can think of. I kind of got carried away thinking about this, feel free to skip to the end if you get bored.</p>

<p>What will happen differently if I call the police? Well, the police might come try to stop the guy. They may or may not get here in time. If they get here in time, the guy will probably try to run away. The police might successfully arrest him. (Note that someone else might call the police if I don’t, so I should discount the value of calling the police somewhat if it turns out to be positive.)</p>

<p>If the police arrest him, they’ll have to do all the usual things they do when they arrest people, which seem pretty expensive. Maybe they’ll injure him while he’s being arrested—I know that police killing people is rare, but police injuring people might be relatively common. Maybe they’ll make him go to court. I think you can go to jail for a while for stealing a bike, especially if you’ve stolen bikes before.</p>

<p>I think the outcomes where the police arrest the guy are worse than the outcomes where he steals a bike. All that legal stuff sounds pretty expensive, especially jail.</p>

<p>However, if we don’t arrest this guy now, the counterfactual isn’t just him stealing this bike. It’s him stealing all the bikes he’s going to steal in the future that he’d be prevented from stealing by being arrested.</p>

<p>How bad is stealing bikes? When X steals a bike from Y, then Y loses the original sale price of the bike, plus extra inconvenience from having to replace a bike or deal with arriving at a train station and realizing they don’t have a bike. And X gains the second-hand sale price of the bike, minus the value of their time stealing the bike and then selling it. I think that when bike thieves sell stolen bikes, they probably lose a bunch of the value of the bike. So there are losses to society involved in the theft—the price of the destroyed lock, the difference between the value that the bike owner places on the bike and the value that the thief gets for the bike.</p>

<p>Bike thieves are probably poorer than bike owners though. If we think utility varies as log income, then we just need to compare the percentage of income that the theft affects for both the thief and the owner. If half the value of a bike is destroyed while stealing it, then this is a net positive “transaction” if the bike thief makes less than half as much money as the original owner did.</p>

<p>If this guy gets arrested or has a close call, maybe him and his bike-thief friends will decide to steal fewer bikes. What will they do instead? Will they just live with the reduced income, or get jobs at McDonalds, or use their new spare time to volunteer in museums, or sell heroin to children? How likely are those outcomes and how bad are they?</p>

<p>What are the externalities of stealing bikes? Maybe more people will start to steal bikes. This would result in cyclists having to spend more money on anti-theft devices, or maybe people cycling less. Maybe cyclists will have less desire to live in Oakland. Maybe the crime statistics for the region will rise and house prices will be depressed. Crime is pretty bad for a neighborhood, I hear? Maybe reducing crime is really valuable and I should hope to reduce theft for that reason.</p>

<p>Are there any other reasons to want to jail bike thieves? Maybe they’re also inclined to other crimes which have higher costs to society, like murder or robbery?</p>

<p>According to the internet, it costs about $30k per year to keep someone in jail. If the thief goes to jail and doesn’t steal any bikes while in jail, then society gets the benefit of not as many bikes being stolen. If the thief stole one $400 bicycle per day and destroyed half its value, that would be $73k saved by them being in jail. That seems like suspiciously high income (and tax-free!), so maybe stealing bikes isn’t actually that lucrative. Maybe bike thieves try to steal as few bikes as they can? If they steal only as many bikes as they have to (and stealing bikes destroys half the value), then it’s only good to jail them if their income is greater than $30k a year.</p>

<p>… And so on.</p>

<p>I think that thinking like this is a really useful skill. I don’t quite remember how I acquired it. I think LessWrong was really helpful, as was reading and participating in discussions about EA various places on the internet, and also going to the Stanford EA meetups. Other great sources of this kind of reasoning include Slate Star Codex, Overcoming Bias, and Meteuphoric.</p>

<p>I wish that my 17 year old self had taken a class on this kind of reasoning. I think you could teach a class like that. It would involve a little bit of economics, and an explanation of counterfactual reasoning and expected values, and most of the assessment would involve writing down reasoning along the lines of the stuff I wrote above.</p>

<p>This kind of reasoning is very useful for cause prioritization. It also seems to be a kind of reasoning that GiveWell does a lot.</p>

<p>Maybe someone should offer to help train people in this kind of reasoning. You could give people questions along the lines of the one I discussed above, and then get them to write up their thoughts, and then comment on them. Maybe this would be valuable for helping EAs get better at thinking about EA topics.</p>

<p>Is there a better name for this kind of reasoning? Are there any other good resources for learning it? What are the best examples of this kind of reasoning being laid out extremely explicitly in an EA context?</p>

<hr />

<p>Turns out that this example of this kind of reasoning really pisses people off. You can view the comment shitstorm <a href="https://www.facebook.com/bshlgrs/posts/10208229326305580">here</a>.</p>

  </div>

  <hr />

  <h2><a href="/2016/07/29/porn.html"> Do people date less if they have easy access to porn?</a></h2>

  <p class="post-meta"><time datetime="2016-07-29T00:00:00-07:00" itemprop="datePublished">Jul 29, 2016</time></p>

  <div class="shrink-headings">
    <p>There’s some evidence that access to pornography decreases sexual assault and child abuse. The proposed mechanism is that horny people get to watch more porn, and this makes them less sexually frustrated, which makes rape seem less tempting. Analogously, violent movies seem to reduce violence in the short term. Slate Star Codex discusses both of these effects <a href="http://slatestarcodex.com/2013/06/22/social-psychology-is-a-flamethrower/">here</a>. In particular, <a href="https://maggiemcneill.files.wordpress.com/2012/04/pornography-rape-and-the-internet.pdf">this linked paper</a> considers all the objections that I’d thought of and seems pretty reasonable.</p>

<p>But rape is pretty dangerous and immoral. Most people do less extreme things when they’re feeling libidinous. For example, they might try to have one night stands, or might try to find a sexual partner. If access to pornography has a big enough affect on rape to be measurable, it seems very plausible that it would also cause a noticeable reduction in dating and casual sex.</p>

<p>I would love to find data to test this hypothesis. Rates of sexual assault are measured quite carefully and are publicly available. I’m not sure of a good proxy for rates of romantic relationships. Some shitty ideas include: flower sales, rates of bookings at nice restaurants, pregnancy rates, contraceptive sales. You’d have to be careful when during this analysis, because there are lots of confounding factors and I’m not sure how they play into each other.</p>

  </div>

  <hr />

  <h2><a href="/2016/07/02/graph.html"> Terse notes on graph algorithms</a></h2>

  <p class="post-meta"><time datetime="2016-07-02T00:00:00-07:00" itemprop="datePublished">Jul 2, 2016</time></p>

  <div class="shrink-headings">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

<p>As part of my work at Triplebyte, I spend some time explaining algorithms to people. On some topics, my explanations are quite different to the explanations that students normally see. Here is my attempt to tersely sketch my explanation of the differences between graph search algorithms.</p>

<p>When you do a graph search, you basically do it by maintaining some set of nodes that you need to explore at some point. Graph search looks something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def search(graph, start_node):
  explored = set()
  frontier = set()

  while frontier:
    node = frontier.pop()

    # skip this node if we've already explored it
    if node in explored:
      next

    explored.add(node)

    for neighbor in graph.neighbors(node):
      if neighbor not in explored:
        frontier.add(node)

  return explored
</code></pre>
</div>

<p>That algorithm returns a set of nodes which it could reach from <code class="highlighter-rouge">start_node</code>.</p>

<p>In the <code class="highlighter-rouge">node = frontier.pop()</code> line, which node should we pop from the frontier?</p>

<p>We could have <code class="highlighter-rouge">frontier</code> be a stack, which uses a last-in-first-out rule. If we do that, our graph search is a depth-first search.</p>

<p>Alternatively, we could have <code class="highlighter-rouge">frontier</code> be a queue. Queues give you elements in a first-in-first-out order. Assuming our graph is unweighted, this means that you’re always going to explore nodes closest to the start node before nodes farther away. So if you are keeping track of the path, you’re guaranteed to find the shortest path from <code class="highlighter-rouge">start_node</code> to every other node.</p>

<p>So <strong>BFS will get you the shortest path from one node to another on an unweighted graph, while DFS makes no such guarantee. BFS gets you shortest paths because it explores the nodes in ascending order of distance from the start node.</strong></p>

<p><strong>Resources on this:</strong></p>

<ul>
  <li><a href="https://www.cs.usfca.edu/~galles/visualization/BFS.html">visualization</a></li>
  <li><a href="https://www.quora.com/Graph-Theory-What-is-the-difference-between-depth-first-search-and-breadth-first-search/answer/Eliot-Ball">similar explanation on Quora</a></li>
</ul>

<h3 id="generalizing-to-weighted-graphs">Generalizing to weighted graphs</h3>

<p>Why does BFS always get shortest paths? Because it explores nodes in order of their distance from the start node, and once it’s explored a node it never explores it again. So each node will only be explored via its shortest path.</p>

<p>So the key is the FIFO structure of the queue–because the graph is unweighted, if you explore nodes in the order in which you first encounter them, you’re finding the shortest paths.</p>

<p>But that doesn’t work for weighted graphs, because FIFO queues don’t take into account the edge costs. We still want to explore nodes in ascending order of distance from the start node. How can we do this?</p>

<p>Easy! Instead of a FIFO queue, we can use a priority queue, where the priority of each node in the queue is its distance from the start node.</p>

<p><strong>This is known as Dijkstra’s algorithm. It’s just BFS generalized to weighted graphs by using a priority queue instead of a FIFO queue.</strong></p>

<h3 id="limitations-of-dijkstras-algorithm">Limitations of Dijkstra’s algorithm</h3>

<p>Dijkstra’s algorithm finds shortest paths because it explores all the nodes in ascending order of their distance from the start node.</p>

<p>If your graph has negative edge weights in it, Dijkstra’s algorithm will not correctly explore the graph in ascending order of distance. This means that it might not return shortest paths.</p>

<p>So <strong>Dijkstra’s algorithm only finds shortest paths on graphs with positive edge weights.</strong></p>

<h3 id="other-notes">Other notes</h3>

<p>You can <a href="http://stackoverflow.com/questions/69192/how-to-implement-a-queue-using-two-stacks">implement a queue with two stacks</a>. Your explored set should be implemented as a hash set, to minimize lookup times. You can implement a priority queue with a binary heap.</p>

<p>My graph search implementation above involves adding the same node to <code class="highlighter-rouge">frontier</code> multiple times. In the case of BFS and DFS, this is unhelpful and you should consider adding an auxilliary hash set which stores the contents of <code class="highlighter-rouge">frontier</code> and allows you to quickly check whether nodes are in it and then avoid adding them to the frontier set if they’re already in there. However, in the case of Dijkstra’s algorithm, we might find a shorter path to a node after the node has already been added to the priority queue. In my code above, this case is handled by the logic to skip exploring a node if it’s already been explored. So it’s only going to actually be explored with its lowest priority. If you want to be super fancy, you can instead do this by using a priority queue which quickly allows you to decrease the priority of one of its elements. You can implement a queue which efficiently supports this <code class="highlighter-rouge">decreaseKey</code> operation with a Fibonacci heap, which lets you do <code class="highlighter-rouge">decreaseKey</code> in amortized $l O(1)$ time. However Fibonacci heaps are massively complicated and have a big constant factor (due to the fact that you can’t represent them in an array like binary heaps), so you probably shouldn’t actually do this.</p>

<p>DFS usually takes less memory than BFS. <a href="https://www.quora.com/Why-is-DFS-usually-more-space-efficient-than-BFS">Explanation here</a>. So if you need to completely explore a graph, DFS is better.</p>

<p>If you need to explore a graph roughly in order but don’t want to pay the memory cost of BFS, you can use <a href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search">iterative deepening depth-first search</a>.</p>

<p><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> is a modification of Dijsktra’s algorithm which uses a heuristic added to the distance from the start node as the priority in the priority queue. If this heuristic always underestimates the distance from the node to the end node, <strong>A* will give you correct results</strong>. <strong>A* needs to have an optimistic heuristic for the same reason that Dijkstra’s algorithm fails on graphs with negative edge weights.</strong></p>

<p>If you want to find shortest paths on a graph with negative edge weights, you can use the <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall algorithm</a>, which is much slower than the graph search algorithms I’ve been describing, because it can’t only look at nodes once and then be confident that it has found the shortest path to them.</p>

<h2 id="questions-to-test-your-understanding">Questions to test your understanding</h2>

<p><strong>Does Dijkstra’s algorithm find shortest paths on a graph if some of its edges have weight 0?</strong> <a role="button" data-toggle="collapse" href="#q1">
  show answer
</a></p>

<div class="collapse" id="q1">
  <div class="well">
    Yes, because the nodes are still going to be explored in ascending order of distance from the start. If I'm exploring a node which is 6.7 away from the start node, and I see it have an edge with weight 0, then I'll push that neighbor node into the priority queue with priority 6.7. It will be explored before any nodes farther away from the start are explored.
  </div>
</div>

<p><strong>Does BFS find shortest paths on a graph which is weighted, but all its edge weights are the same positive number?</strong> <a role="button" data-toggle="collapse" href="#q2">
  show answer
</a></p>

<div class="collapse" id="q2">
  <div class="well">
    Yes.
  </div>
</div>

<p><strong>If you want to find the shortest path from point A to point B on an unweighted graph, should you use BFS or DFS?</strong> <a role="button" data-toggle="collapse" href="#q3">
  show answer
</a></p>

<div class="collapse" id="q3">
  <div class="well">
    You should use BFS, because unlike DFS it finds shortest paths.
  </div>
</div>

<p><strong>Suppose I’m implementing a garbage collection algorithm, which is designed to find all the objects in memory which are still reachable, and then delete all the other elements. I want to do this by a graph search starting from the objects pointed to by local variables. Should I use BFS or DFS?</strong> <a role="button" data-toggle="collapse" href="#q4">
  show answer
</a></p>

<div class="collapse" id="q4">
  <div class="well">
    You should use DFS, because you need to explore the entire graph and DFS usually requires less memory than BFS to explore an entire graph.
  </div>
</div>


  </div>

  <hr />

  <h2><a href="/2016/07/02/sms.html"> SMS vs email responsiveness</a></h2>

  <p class="post-meta"><time datetime="2016-07-02T00:00:00-07:00" itemprop="datePublished">Jul 2, 2016</time></p>

  <div class="shrink-headings">
    <p>Here’s something I’ve learned recently: People are waaaaay more responsive to SMS than email. If you need to get a quick short response from someone, you should definitely text them.</p>

<p>Why is this? Two hypotheses:</p>

<ol>
  <li>I’m burning some collective commons where SMS is reserved for higher priority communications and by exploiting this, I’m degrading its signal to noise ratio.</li>
  <li>You can’t write elegantly on SMS because of the phone keyboard limitation, so you feel less awkward about replying with super short messages like “ok then”. This means that you’re less tempted to put off replying. (I have a web interface to SMS, so this limitation doesn’t actually change my behavior. But this limitation changes the social norms in a useful way even if it’s not present for everyone.)</li>
</ol>

<hr />

<p><a href="https://www.facebook.com/bshlgrs/posts/10208079991852312">view responses on Facebook</a></p>

  </div>

  <hr />


<p><a href="/posts">All posts</a></p>

<p><a href="/feed.xml">RSS feed</a></p>

<script>
$(function() {
  $(".shrink-headings").map(function(idx, div) {
    $(div).html(
      $(div)
        .html()
        .replace(/<h4/g, "<h5")
        .replace(/<h3/g, "<h4")
        .replace(/<h2/g, "<h3")
    )
  })
})
</script>


      <hr/>

<div class="PageNavigation">
  
  
</div>

    </div>
    <div class="col-sm-3 col-sm-offset-1">
      <img src="https://scontent-sjc2-1.xx.fbcdn.net/hphotos-xtp1/t31.0-8/11154688_10205041372168719_3725604149367069581_o.jpg" class="img-responsive" alt="Picture of Buck">
      
<hr/>
<a class="arrow" href="/"><strong>Buck</strong></a>
<ul>
  <li><a class="arrow" href="/about">About</a>
    <ul>
      <li><a href="http://triplebyte.com?ref=shlegeris.com">Triplebyte</a></li>
    </ul>
  </li>
  <li>Links
    <ul>
      <li>
          <a class="arrow" href="http://github.com/bshlgrs">GitHub</a>
      </li>
      <li>
          <a class="arrow" href="mailto:bshlegeris@gmail.com">Email</a>
      </li>
      <li>
          <a class="arrow" href="http://www.facebook.com/bshlgrs">Facebook</a>
      </li>
      <li>
          <a class="arrow" href="http://lnkd.in/bnBJ6EF">LinkedIn</a>
      </li>
    </ul>
  </li>
  <li><a class="arrow external" href="/anonymous_feedback">Anonymous feedback</a></li>

  <li><a href="/posts" class="arrow">Blog</a> (<a href="/best" class="arrow">Best posts</a>)
    <ul>
      
        <li>
          <a class="arrow" href="/2016/08/16/dumb.html">Dumb ideas</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/formatting.html">Using formatting in writing</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/bootcamp-attendees.html">My advice to people about to attend bootcamps</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/algorithms.html">My advice on studying algorithms</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/07/31/counterfactuals.html">Counterfactual reasoning</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/07/29/porn.html">Do people date less if they have easy access to porn?</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/07/02/graph.html">Terse notes on graph algorithms</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/07/02/sms.html">SMS vs email responsiveness</a>
        </li>
      
    </ul>
  </li>
  <li>
      <a class="arrow" href="/cute">Pictures of me</a>
  </li>
</ul>

    </div>
  </div>
</div>




    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Buck Shlegeris</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Buck Shlegeris</li>
          <li><a href="mailto:bshlegeris@gmail.com">bshlegeris@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/bshlgrs"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">bshlgrs</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/bshlgrs"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">bshlgrs</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Website of Buck Shlegeris.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

<script>
if (window.location.hostname == "bshlgrs.github.io") {
  window.location.hostname = "shlegeris.com";
}
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52980069-1', 'auto');
  ga('send', 'pageview');

</script>



</html>

