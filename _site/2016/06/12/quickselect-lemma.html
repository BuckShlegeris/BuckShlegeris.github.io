<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Quickselect on an unordered array and an order statistic tree</title>
  <meta name="description" content="I did this work myself, so there are probably mistakes. I think the conclusion is right though.">


  <link rel="stylesheet" href="/bootstrap.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://shlegeris.com/2016/06/12/quickselect-lemma.html">
  <link rel="alternate" type="application/rss+xml" title="Buck Shlegeris" href="http://shlegeris.com/feed.xml">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$l', '$'] ],
        displayMath: [ ['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      messageStyle: "none",
      "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
    });
  </script>
  <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  <script src="/jquery.js"></script>
  <script type="text/babel" src="/main.js"></script>
  
</head>


  <body>

    

    <div class="container">
  <div class="row">
    <div class="col-sm-7 col-sm-offset-1 markdownify">
      <h1 class="post-title " itemprop="name headline">Quickselect on an unordered array and an order statistic tree</h1>
      <p class="post-meta"><time datetime="2016-06-12T00:00:00-07:00" itemprop="datePublished">Jun 12, 2016</time></p>

      <hr/>

      <p><strong>I did this work myself, so there are probably mistakes. I think the conclusion is right though.</strong></p>

<p>Suppose I have an <a href="https://en.wikipedia.org/wiki/Order_statistic_tree">order statistic tree</a> with $l n$ elements and an unordered list with $l m$ elements. Let’s say for the sake of simplicity that both are representing a set of items with no duplicates, and their intersection is empty.</p>

<p>If you want to find the $l k$th element of the order statistic tree, you can do that in $l O(log(n))$ time. And if you want to find the $l k$th element of the array, you can use <a href="https://en.wikipedia.org/wiki/Quickselect">quickselect</a> and get it in $l O(m)$ time. I want to find the $l k$th smallest item in the disjoint union of these lists. How quickly can I do this?</p>

<p>You can do it trivially in $l O(m + n)$ time, by flattening the order statistic tree (which I’ll call an OST from here onwards) onto the end of the array. Or you can add everything in the array to the OST and then query the OST, in $l O(m \cdot \log(n + m))$ time.</p>

<p>I have found solutions that run in $l O(m \cdot \log(n))$, $l O(m + \log(m) \cdot \log(n))$, and $l O(m + \log(n))$. The last of these is really complicated and annoying; the first two are pretty simple.</p>

<h2 id="order-statistic-trees">Order statistic trees</h2>

<p>I’m going to write code in Ruby, in which the <code class="highlighter-rouge">filter</code> method is stupidly named <code class="highlighter-rouge">select</code>. OSTs are usually presented with a method called <code class="highlighter-rouge">select(k)</code> which finds the $l k$th smallest element. In this post I’m going to use the method name <code class="highlighter-rouge">find_kth_smallest</code> instead.</p>

<p>I’m going to assume that my OSTs have the following methods:</p>

<ul>
  <li><code class="highlighter-rouge">smallers</code>: returns the left subtree</li>
  <li><code class="highlighter-rouge">largers</code>: returns the right subtree</li>
  <li><code class="highlighter-rouge">pivot</code>: returns the value of the root node</li>
  <li><code class="highlighter-rouge">count</code>: returns the number of items in the node</li>
  <li><code class="highlighter-rouge">find_kth_smallest(k)</code>: as discussed above</li>
  <li><code class="highlighter-rouge">rank(x)</code>: finds the number of elements in the OST smaller than <code class="highlighter-rouge">x</code>. This takes $l O(\log(n))$ in an OST.</li>
  <li><code class="highlighter-rouge">split_on_left_by_value(x)</code>: returns a new tree with only the items in the OST which are less than <code class="highlighter-rouge">x</code>. If our OSTs are immutable, this only takes $l\log(n)$ time.</li>
  <li><code class="highlighter-rouge">split_on_right_by_value(x)</code>: like <code class="highlighter-rouge">split_on_left_by_value</code>, but the other side.</li>
</ul>

<h2 id="standard-quickselect">Standard quickselect</h2>

<p>Just for reference, here’s an unoptimized implementation of quickselect. This has average case performance $l O(n)$.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># assumes that the list has all unique elements</span>
<span class="c1"># returns the same thing as array.sort[n]</span>
<span class="k">def</span> <span class="nf">quickselect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="c1"># choose a random pivot</span>
  <span class="n">pivot_element</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">sample</span>

  <span class="n">smallers</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot_element</span> <span class="p">}</span>
  <span class="n">largers</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot_element</span> <span class="p">}</span>

  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">smallers</span><span class="p">.</span><span class="nf">length</span>
    <span class="n">quickselect</span><span class="p">(</span><span class="n">smallers</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">smallers</span><span class="p">.</span><span class="nf">length</span>
    <span class="n">pivot_element</span>
  <span class="k">else</span>
    <span class="n">quickselect</span><span class="p">(</span><span class="n">largers</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">smallers</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>This has average case $l O(n)$ performance because the recurrence relation is:</p>

<script type="math/tex; mode=display">f(n) = f\left(\frac{n}2\right) + n</script>

<h2 id="modified-quickselect-attempt-1-l-om-cdot-logn">Modified quickselect, attempt 1: $l O(m \cdot \log(n))$</h2>

<p>Let’s modify this to also use an OST.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># OST has size n</span>
<span class="c1"># array has size m</span>
<span class="c1"># this returns the same thing as (array + ost.to_a).sort[k]</span>
<span class="k">def</span> <span class="nf">double_quickselect_v1</span><span class="p">(</span><span class="n">ost</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
  <span class="n">smallers</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">ost</span><span class="p">.</span><span class="nf">pivot</span> <span class="p">}</span>
  <span class="n">largers</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">ost</span><span class="p">.</span><span class="nf">pivot</span> <span class="p">}</span>

  <span class="n">number_of_smaller_things</span> <span class="o">=</span> <span class="n">smallers</span><span class="p">.</span><span class="nf">length</span> <span class="o">+</span> <span class="n">ost</span><span class="p">.</span><span class="nf">smallers</span><span class="p">.</span><span class="nf">count</span>

  <span class="k">if</span> <span class="n">number_of_smaller_things</span> <span class="o">&gt;</span> <span class="n">k</span>
    <span class="n">double_quickselect_v1</span><span class="p">(</span><span class="n">smallers</span><span class="p">,</span> <span class="n">ost</span><span class="p">.</span><span class="nf">smallers</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">number_of_smaller_things</span> <span class="o">==</span> <span class="n">k</span>
    <span class="n">ost</span><span class="p">.</span><span class="nf">pivot</span>
  <span class="k">else</span>
    <span class="n">double_quickselect_v1</span><span class="p">(</span><span class="n">largers</span><span class="p">,</span> <span class="n">ost</span><span class="p">.</span><span class="nf">largers</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">number_of_smaller_things</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Every time we make a recursive call, our order statistic tree halves in size. Our array might not get smaller though: eg if everything in your array is smaller than everything in your OST. Our OST has depth $l \log(n)$, and in the worst case you need to iterate over everything in your array every time. So this is $l O(m \cdot \log(n))$.</p>

<p>Can we do better? I think we can. Intuitively, it seems like this algorithm works to shrink the OST as fast as possible, and not really worry about the array. But the array is where most of the cost comes from. So we should try to organize this algorithm so that instead of halving the size of the OST every time, it halves the size of the array every time.</p>

<h2 id="modified-quickselect-attempt-2-l-om--logm-cdot-logn">Modified quickselect, attempt 2: $l O(m + \log(m) \cdot \log(n))$</h2>

<p>Instead of using the OST’s pivot, let’s pivot on a randomly selected member of the array, like in normal quickselect. This means that the array is probably going to shrink with every recursive call.</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># OST has size n</span>
<span class="c1"># array has size m</span>
<span class="c1"># this returns the same thing as (array + ost.to_a).sort[k]</span>
<span class="k">def</span> <span class="nf">double_quickselect_v2</span><span class="p">(</span><span class="n">ost</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
  <span class="n">pivot_element</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">sample</span>
  <span class="n">smallers</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot_element</span> <span class="p">}</span>
  <span class="n">largers</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot_element</span> <span class="p">}</span>

  <span class="n">number_of_smaller_things</span> <span class="o">=</span> <span class="n">smallers</span><span class="p">.</span><span class="nf">length</span> <span class="o">+</span> <span class="n">ost</span><span class="p">.</span><span class="nf">rank</span><span class="p">(</span><span class="n">pivot_element</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">number_of_smaller_things</span> <span class="o">&gt;</span> <span class="n">k</span>
    <span class="n">double_quickselect_v2</span><span class="p">(</span><span class="n">smallers</span><span class="p">,</span>
                        <span class="n">ost</span><span class="p">.</span><span class="nf">split_on_right_by_value</span><span class="p">(</span><span class="n">pivot_element</span><span class="p">),</span>
                        <span class="n">k</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">number_of_smaller_things</span> <span class="o">==</span> <span class="n">k</span>
    <span class="n">ost</span><span class="p">.</span><span class="nf">pivot</span>
  <span class="k">else</span>
    <span class="n">double_quickselect_v2</span><span class="p">(</span><span class="n">largers</span><span class="p">,</span>
                        <span class="n">ost</span><span class="p">.</span><span class="nf">split_on_left_by_value</span><span class="p">(</span><span class="n">pivot_element</span><span class="p">),</span>
                        <span class="n">k</span> <span class="o">-</span> <span class="n">number_of_smaller_things</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>So now the array is going to shrink on average by a factor of 2 every recursive call, but in the worst case the tree will stay the same size every time. So we now expect to $l \log(m)$ recursive calls, for a total cost of $l O(m + \log(m) \cdot \log(n))$.</p>

<p>(Incidentally, calling <code class="highlighter-rouge">ost.split_on_left_by_value</code> doesn’t affect the asymptotic runtime of this function, because this only decreases the size of <code class="highlighter-rouge">ost</code> by a constant multiplier in expectation, and it doesn’t cause <code class="highlighter-rouge">ost.rank(pivot_element)</code> to run asymptotically faster.)</p>

<p>Okay, this is better. But can we improve it even more?</p>

<h2 id="sketch-of-a-l-om--logn-solution">Sketch of a $l O(m + \log(n))$ solution</h2>

<p>I’m pretty sure I have an optimal solution, but it’s really complicated and annoying.</p>

<p>The problem was that in the previous algorithms, sometimes I computed expensive things for the data structures without any guarantee that they’d end up smaller. This time, I want to either compute tertiles for a data structure and shrink it, or ignore it.</p>

<p>For this to work, we’re going to need our OST to be a <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">weight-balanced tree</a>. Let’s set $l \alpha = \frac 14$. (Actually, I think this algorithm works with non-weight-balanced trees, but I don’t know how to prove the time bound without the weight balance.)</p>

<p>Here’s how: At the start of every recursive call, we look at the relative sizes of the two data structures. If one is much larger than the other, we’re going to shrink the large one and ignore the small one. If they’re within a factor of 2 of each other, we’re going to call the expensive methods on both then shrink one of them.</p>

<p>If you want the gory details, read on.</p>

<h3 id="case-1-one-is-much-larger-than-the-other">Case 1: one is much larger than the other</h3>

<p>Suppose one data structure has more than three times as many things in it as the other one does. Let’s call the two data structures <code class="highlighter-rouge">Big</code> and <code class="highlighter-rouge">Small</code>. <code class="highlighter-rouge">Big</code> has size $l b$, <code class="highlighter-rouge">Small</code> has size $l s$.</p>

<p>Suppose we have 100 things in <code class="highlighter-rouge">Big</code> and 10 things in <code class="highlighter-rouge">Small</code>. We want to find the 15th largest thing in <code class="highlighter-rouge">Big ++ Small</code>. Let’s call the result $l x$.</p>

<p>$l x$ can’t be more than <code class="highlighter-rouge">Big.find_kth_smallest(15)</code>, because by definition there are 15 things in <code class="highlighter-rouge">Big</code> less than that.</p>

<p>And $l x$ can’t be less than <code class="highlighter-rouge">Big.find_kth_smallest(5)</code>, because there are only 5 things in <code class="highlighter-rouge">Big</code> less than that, and there are only 10 things in Small.</p>

<p>So if we’re looking for the <code class="highlighter-rouge">k</code>th item in <code class="highlighter-rouge">Big ++ Small</code>, we can discard everything bigger than <code class="highlighter-rouge">Big.find_kth_smallest(k)</code>, and everything smaller than <code class="highlighter-rouge">Big.find_kth_smallest(k + s)</code>.</p>

<h4 id="case-1a-the-array-is-larger">Case 1a: the array is larger</h4>

<p>If the array is the larger data structure, then we do this discard by calling quickselect twice and copying everything between the two results to a new array. This takes $l O(m)$ time, and the resulting array is at most size $l s$. So we made our array half its original size.</p>

<h4 id="case-1b-the-ost-is-larger">Case 1b: the OST is larger</h4>

<p>If the tree is the larger data structure, then things are somewhat more annoying, because we only want to take constant time.</p>

<p>Selecting exactly the first $l k$ things in an OST takes $l \log(n)$ time. I’m going to suggest that instead of selecting exactly the first $l k$ things, we should go a few layers deep in our OST and then delete only the nodes which we know we can safely delete.</p>

<p>Because we’re using weight-balanced trees with a weight balancing factor of $l \frac 14$, we might need to go down maybe 3 layers in order to get a node with enough weight that deleting it deletes half the weight that you’d be able to delete if you called <code class="highlighter-rouge">split_on_left_by_value</code>. (I’m not sure about the number 3 being correct, but I think this is true for some constant.)</p>

<p>We could safely remove $l \frac 12$ of the tree if we used the normal split methods. We’re going to remove more than half of that, so at worst our tree will end up $l\frac 34$ of its original size.</p>

<p>So in both cases, we end up with the bigger data structure being a constant factor smaller.</p>

<h3 id="case-2-the-data-structures-are-a-similar-size">Case 2: the data structures are a similar size</h3>

<p>Oh man, this gets messy. I’m going to call this bit an “algorithm sketch”, because then you can’t criticise me for being handwavy.</p>

<p>Get approximate tertiles from the OST and exact tertiles from the array. This takes $l O(m)$ time for the array and $l O(1)$ time for the OST.</p>

<p>Then you compare these two inter-tertile ranges. There are three cases: they can intersect, they can be disjoint, or one can be inside the other. In each of these cases, based on your value of $l k$ you can rule out at least a third of at least one of the two data structures. This is just a massive mess of cases. Here’s a diagram of one way it can play out when the ranges intersect:</p>

<p><img src="/img/ost_diagram.jpg" alt="diagram" /></p>

<p>This is a diagram of what happens when one data structure has 30 items and the other has 60 items. It contains all of the different cases for $l k$. For example, when $l k$ is 35, then we can discard the upper and lower thirds of the 30 item data structure, and we can discard the upper third of the 60 item data structure.</p>

<p>You can draw similar diagrams for the other cases.</p>

<p>This part is the sketchiest part of the whole algorithm. I’m pretty sure that you can always decrease at least one of the data structures by one third. I’m not sure if you can always shrink both of them. I’m not sure how much you can shrink the OST in constant time; I’m pretty sure you can do at least $l \frac 16$, and I think that for any fraction less than $l \frac 13$, you can choose a node depth such that you can always cut that fraction out in constant time.</p>

<h3 id="runtime-of-this-solution">Runtime of this solution</h3>

<p>If one of the data structures starts out much larger than the other one, it will shrink until they’re similar sizes. This takes $l O(m)$ time for the array and $l O(\log(n))$ time for the OST.</p>

<p>Once they’re the same size, I think that at least one of them will both shrink by one third every time. So we have the recurrence relation:</p>

<script type="math/tex; mode=display">f(n, m) = f \left( \frac {2n}3, \frac {2m}3\right) + m + 1</script>

<p>which evaluates to $l \log(n) + m$.</p>

<h2 id="conclusion">Conclusion</h2>

<p>So we can do quick select on an OST and array at the same time in $l O(m + \log(n))$.</p>

<p>My work here leaves a lot to be desired. Most obviously, my fastest algorithm is extremely complicated and inelegant; I bet that can be simplified.</p>


      <hr/>

<div class="PageNavigation">
  
    <a class="prev" href="/2016/06/02/say.html">&laquo; Not thinking of things I can't say</a>
  
  
    <a class="pull-right" href="/2016/06/15/multi-sorted-array-quickselect.html">Quickselect on multiple sorted arrays &raquo;</a>
  
</div>

    </div>
    <div class="col-sm-3 col-sm-offset-1">
      <img src="https://scontent-sjc2-1.xx.fbcdn.net/hphotos-xtp1/t31.0-8/11154688_10205041372168719_3725604149367069581_o.jpg" class="img-responsive" alt="Picture of Buck">
      
<hr/>
<a class="arrow" href="/"><strong>Buck</strong></a>
<ul>
  <li><a class="arrow" href="/about">About</a>
    <ul>
      <li><a href="http://triplebyte.com?ref=shlegeris.com">Triplebyte</a></li>
    </ul>
  </li>
  <li>Links
    <ul>
      <li>
          <a class="arrow" href="http://github.com/bshlgrs">GitHub</a>
      </li>
      <li>
          <a class="arrow" href="mailto:bshlegeris@gmail.com">Email</a>
      </li>
      <li>
          <a class="arrow" href="http://www.facebook.com/bshlgrs">Facebook</a>
      </li>
      <li>
          <a class="arrow" href="http://lnkd.in/bnBJ6EF">LinkedIn</a>
      </li>
    </ul>
  </li>
  <li><a class="arrow external" href="/anonymous_feedback">Anonymous feedback</a></li>

  <li><a href="/posts" class="arrow">Blog</a> (<a href="/best" class="arrow">Best posts</a>)
    <ul>
      
        <li>
          <a class="arrow" href="/2016/09/03/tax-percentiles.html">Should we encourage price discrimination based on income?</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/09/03/printers.html">Printers and price discrimination</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/30/white-dudes.html">Privilege and polite disagreement</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/24/armchair.html">The Armchair Economist on moral philosophy</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/16/dumb.html">Dumb ideas</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/formatting.html">Using formatting in writing</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/bootcamp-attendees.html">My advice to people about to attend bootcamps</a>
        </li>
      
        <li>
          <a class="arrow" href="/2016/08/14/algorithms.html">My advice on studying algorithms</a>
        </li>
      
    </ul>
  </li>
  <li>
      <a class="arrow" href="/cute">Pictures of me</a>
  </li>
</ul>

    </div>
  </div>
</div>




    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Buck Shlegeris</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Buck Shlegeris</li>
          <li><a href="mailto:bshlegeris@gmail.com">bshlegeris@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/bshlgrs"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">bshlgrs</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/bshlgrs"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">bshlgrs</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Website of Buck Shlegeris.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

<script>
if (window.location.hostname == "bshlgrs.github.io") {
  window.location.hostname = "shlegeris.com";
}
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52980069-1', 'auto');
  ga('send', 'pageview');

</script>



</html>

